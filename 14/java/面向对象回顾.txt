类：对同一类事物的共性的抽取
实例：通过类（模板）得到的一个具体的实际个体


1.封装
将对象的属性隐藏起来，提供公共的getter,seeter方法去访问

2.继承
继承是在现有类的基础上创建新类的一种技术。
现有的类称为父类（基类），创建出的新的类称为子类（派生类）。
关键字：extends
java中的继承是单继承。

3.多态
运行时（动态）多态：当父类的引用指向子类的实例的时候，如果此时调用父类的方法，
那么如果子类重写了该方法，会根据子类对象的不同而引发不同的行为。

编译时（静态）多态：方法的重载


4.重载
在同一个类中或继承关系的类中，有一系列功能相同的方法，这些方法方法名相同，参数列表不同，这组方法构成方法重载。

5.重写
在有继承关系的两个类中，如果子类的方法的方法名，参数列表，返回值都与父类的方法相同，那么子类的方法重写了父类的方法。（方法重写，方法覆盖）
重写的方法的可见性不能低于父类的方法。

6.按值传递和按引用传递
按值传递：在方法的调用中，如果传入方法中的参数是基本数据类型，那么在方法中对（形）参数的改变不会影响调用方法时传入的（实）参数的值。
public static void main(String args[]){
	int i = 1;
	//实参
	test(i);
}
						//形参
public static void test(int i){
	i++;
}

按引用传递：在方法的调用中，如果传入方法中的参数是引用数据类型，那么在方法中对（形）参数的改变会影响调用方法时传入的（实）参数的值。（String是个特例）
本质：参数在方法中传递时，实际上传的是参数在栈区中的值的一个副本。


7.构造函数
对对象进行初始化
构造函数的写法：
a.方法名与类名相同
b.构造函数没有返回值，也不需要使用void修饰
c.构造函数由程序自动调用，不需要显示调用

8.this
表示当前活动对象的引用
this.成员变量
this.成员方法
this(参数列表);

9.super
表示当前活动对象的直接父类
super.成员变量
super.成员方法
super(参数列);//调父类的构造方法

10.static
可以用来修饰成员变量----》静态变量
可以用来修饰成员方法----》静态方法

静态变量和实例变量的区别？
静态变量直接使用类名调用，不依赖于任何实例，被类的所有实例共享，在内存中只有一份拷贝。
实例变量依赖于特定的对象，每一个对象对其都会有一份拷贝，并且互不影响。

静态方法或者中可以调用this,super或者成员变量，成员方法吗？
不可以

11.访问修饰符
private:在同一个类中可以访问
default：在同一个类中或者同一个包中可以访问
protected：在同一个类中或者同一个包中或者子类中可以访问
public：公共的

12.instanceof
实例A instanceof 类B
判断实例A 是否是 类B或者类B的子类的一个实例

抽象类:
1.抽象方法不能是private,final,static的,可以是默认,protected
2.抽象类中不一定有抽象方法,但抽象方法一定在抽象类中
3.抽象类中可以有非抽象方法,可以有属性
4.抽象类可以有构造方法,但抽象类不能直接new出来;在new子类对象的过程中会调用抽象父类的构造方法,但抽象父类不会被创建实例,因此构造方法的调用不见得会创建出对象,它只是创建对象过程中必经的一个过程
5.抽象类可继承别的类,可被子类继承
6.继承了抽象类,就必须重写抽象父类中所有的抽象方法,如果子类不重写抽象方法,那么子类也必须将该方法抽象化,该子类也将成为抽象类

接口:
1.接口不可以被类继承(extends),只能被类实现(implements),接口中不可以有方法体
2.接口中的方法默认是public abstract的,但可以省略不写
3.接口是用来实现的,一个类实现接口就必须实现接口中所有的抽象方法
4.实现多个接口,里面都有一个同名方法,那么实现类只需要写一个
5.接口中的属性是常量
6.接口中只能有抽象方法
7.接口中不能有构造方法,不能被new
8.接口的引用可指向实现类的实例,如果实现了多个接口,多个接口都可以指向实现类的实例

接口与抽象类的区别:
抽象类				接口
有属性				没有属性
常量				常量
有实现方法			没有实现方法
有抽象方法			只能有抽象方法
有构造方法			没有构造方法
被继承				被实现


类与接口的关系
1.类	extends		类
2.类	implements	接口
3.接口	extends		接口

































